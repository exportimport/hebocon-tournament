<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hebocon Tournament Control</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            font-family: 'Arial', sans-serif;
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .urls {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            color: white;
            text-align: center;
        }

        .urls a {
            color: #ff6b35;
            text-decoration: none;
            font-weight: bold;
            margin: 0 15px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .control-panel h2 {
            color: #ff6b35;
            margin-bottom: 20px;
            font-size: 1.8em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .current-match {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .match-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
            font-size: 1.3em;
            font-weight: bold;
            margin-top: 15px;
        }

        .robot-name-display {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 8px;
            min-width: 200px;
            text-align: center;
        }

        .slot-selection {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 20px 0;
        }

        .slot-button {
            background: #34495e;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 150px;
        }

        .slot-button:hover {
            background: #2c3e50;
            transform: translateY(-2px);
        }

        .slot-button.selected {
            background: #ff6b35;
            box-shadow: 0 0 20px rgba(255, 107, 53, 0.5);
        }

        .robot-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
            margin: 20px 0;
        }

        .robot-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
        }

        .robot-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .robot-button .delete-btn {
            position: absolute;
            top: -5px;
            right: -5px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            cursor: pointer;
            display: none;
        }

        .robot-button:hover .delete-btn {
            display: block;
        }

        .quick-add {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 2px dashed #dee2e6;
        }

        .quick-add input {
            background: white;
            border: 2px solid #dee2e6;
            color: #333;
            padding: 10px 15px;
            border-radius: 6px;
            margin: 5px;
            font-size: 14px;
            width: 250px;
        }

        .quick-add button, .action-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            margin: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }

        .quick-add button:hover, .action-button:hover {
            background: #218838;
        }

        .danger {
            background: #dc3545 !important;
        }

        .danger:hover {
            background: #c82333 !important;
        }

        .timer-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .timer-display {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px 20px;
            font-size: 2em;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            color: #333;
            min-width: 120px;
            text-align: center;
        }

        .timer-display.running {
            background: #d4edda;
            border-color: #28a745;
            color: #155724;
            animation: timer-pulse 1s infinite;
        }

        .timer-display.warning {
            background: #fff3cd;
            border-color: #ffc107;
            color: #856404;
        }

        .timer-display.critical {
            background: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
            animation: timer-blink 0.5s infinite;
        }

        .timer-input {
            width: 80px;
            padding: 8px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            text-align: center;
            font-size: 16px;
            font-weight: bold;
        }

        .timer-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .timer-button:hover {
            background: #0056b3;
        }

        .timer-button.start {
            background: #28a745;
        }

        .timer-button.start:hover {
            background: #1e7e34;
        }

        .timer-button.stop {
            background: #dc3545;
        }

        .timer-button.stop:hover {
            background: #c82333;
        }

        @keyframes timer-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        @keyframes timer-blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .timer-display.paused {
            background: #f8f9fa;
            border-color: #6c757d;
            color: #6c757d;
            animation: timer-paused 1.5s infinite;
        }

        @keyframes timer-paused {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.4;
            }
        }

        .round-controls {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .round-button {
            background: #6c757d;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .round-button:hover {
            background: #5a6268;
        }

        .round-button.active {
            background: #ff6b35;
        }

        .status-bar {
            background: #28a745;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-family: monospace;
            margin: 15px 0;
            transition: all 0.3s ease;
        }

        .status-bar.warning {
            background: #ffc107;
            color: #212529;
        }

        .status-bar.error {
            background: #dc3545;
        }

        .actions {
            display: flex;
            gap: 10px;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        /* Bracket Styles */
        .bracket-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .bracket-round {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border: 2px solid #dee2e6;
        }

        .bracket-round h4 {
            color: #495057;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
        }

        .bracket-match {
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .bracket-match:hover {
            border-color: #ff6b35;
            box-shadow: 0 2px 8px rgba(255, 107, 53, 0.2);
        }

        .bracket-match.current {
            border-color: #ff6b35;
            background: #fff5f2;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.3);
        }

        .bracket-match.completed {
            border-color: #28a745;
            background: #f8fff9;
        }

        .bracket-match-header {
            font-size: 12px;
            color: #6c757d;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .bracket-robots {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .bracket-robot {
            padding: 4px 8px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 13px;
            border: 1px solid #dee2e6;
        }

        .bracket-robot.clickable {
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .bracket-robot.clickable:hover {
            background: #e9ecef;
            border-color: #ff6b35;
        }

        .bracket-robot.winner {
            background: #d4edda;
            border-color: #28a745;
            font-weight: bold;
        }

        .bracket-setup {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .bracket-position {
            background: white;
            border: 2px dashed #dee2e6;
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #6c757d;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .bracket-position.filled {
            border-style: solid;
            border-color: #28a745;
            background: #f8fff9;
            color: #333;
            font-weight: bold;
        }

        .bracket-position:hover {
            border-color: #ff6b35;
            background: #fff5f2;
        }

        .bracket-status {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: bold;
        }

        .bracket-status.not-setup {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }

        .bracket-status.setup {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }

        .bracket-status.running {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        .bracket-status.completed {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }

        /* Winner Controls */
        .winner-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 15px 0;
            flex-wrap: wrap;
        }

        .winner-button {
            background: linear-gradient(135deg, #ff6b35 0%, #f7931e 100%);
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            min-width: 200px;
            box-shadow: 0 4px 15px rgba(255, 107, 53, 0.3);
        }

        .winner-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(255, 107, 53, 0.4);
        }

        .winner-button.reset {
            background: linear-gradient(135deg, #6c757d 0%, #495057 100%);
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
        }

        .winner-button.reset:hover {
            box-shadow: 0 8px 25px rgba(108, 117, 125, 0.4);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🤖 HEBOCON TOURNAMENT</h1>
        <p>Live Control Panel</p>
    </div>

    <div class="urls">
        <strong>URLs:</strong>
        <a href="/" target="_blank">Control Panel</a> |
        <a href="/overlay" target="_blank">OBS Overlay</a> |
        <a href="/api/data" target="_blank">API Daten</a>
    </div>

    <!-- Gewinner Animation -->
    <div class="control-panel">
        <h2>🏆 Gewinner Animation</h2>
        <div class="winner-controls">
            <button class="winner-button" onclick="announceWinner('robot1')" id="winnerBtn1">
                🏆 <span id="robot1Name">Roboter 1</span> gewinnt!
            </button>
            <button class="winner-button" onclick="announceWinner('robot2')" id="winnerBtn2">  
                🏆 <span id="robot2Name">Roboter 2</span> gewinnt!
            </button>
            <button class="winner-button reset" onclick="resetWinnerAnimation()">
                🔄 Animation zurücksetzen
            </button>
        </div>
    </div>

    <!-- Tournament Settings -->
    <div class="control-panel">
        <h2>🏆 Tournament Einstellungen</h2>
        <div class="quick-add">
            <h4 style="margin-bottom: 10px; color: #333;">Tournament Titel:</h4>
            <input type="text" id="tournamentTitleInput" placeholder="Tournament Titel" maxlength="50" value="HEBOCON 2025">
            <button onclick="updateTournamentTitle()">💾 Titel setzen</button>
        </div>
    </div>

    <!-- Aktuelle Anzeige -->
    <div class="control-panel">
        <h2>📺 Aktuelle Anzeige</h2>
        <div class="current-match">
            <h3 id="currentRound">Viertelfinale</h3>
            <div class="match-display">
                <div class="robot-name-display" id="currentRobot1">Wackel-Bot 3000</div>
                <div style="font-size: 1.8em;">⚡ VS ⚡</div>
                <div class="robot-name-display" id="currentRobot2">Chaos-Maschine</div>
            </div>
        </div>
        
        <div class="status-bar" id="statusDisplay">
            ✅ Bereit - System läuft
        </div>
    </div>

    <!-- Slot Auswahl -->
    <div class="control-panel">
        <h2>🎯 Roboter Position</h2>
        <div class="slot-selection">
            <button class="slot-button" id="slot1Button" onclick="selectSlot(1)">
                🤖 Roboter 1 auswählen
            </button>
            <button class="slot-button" id="slot2Button" onclick="selectSlot(2)">
                🤖 Roboter 2 auswählen
            </button>
        </div>
    </div>

    <!-- Roboter Auswahl -->
    <div class="control-panel">
        <h2>🤖 Roboter Bibliothek</h2>
        <div class="robot-grid" id="robotGrid">
            <!-- Roboter werden hier eingefügt -->
        </div>

        <div class="quick-add">
            <h4 style="margin-bottom: 10px; color: #333;">Neuen Roboter hinzufügen:</h4>
            <input type="text" id="newRobotInput" placeholder="Roboter Name" maxlength="30">
            <button onclick="addRobot()">➕ Hinzufügen</button>
            
            <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #ddd;">
                <h4 style="margin-bottom: 10px; color: #333;">Test-Daten:</h4>
                <button onclick="generateTestRobots()" style="background: linear-gradient(135deg, #28a745, #20c997); color: white; border: none; padding: 12px 20px; border-radius: 8px; font-size: 14px; font-weight: bold; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(0,0,0,0.2);" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">🎲 16 Test-Roboter generieren</button>
            </div>
        </div>
    </div>

    <!-- Turnier Steuerung -->
    <div class="control-panel">
        <h2>🏆 Turnier Runde</h2>
        <div class="round-controls">
            <button class="round-button" onclick="setRound('Vorrunde')">Vorrunde</button>
            <button class="round-button active" onclick="setRound('Viertelfinale')">Viertelfinale</button>
            <button class="round-button" onclick="setRound('Halbfinale')">Halbfinale</button>
            <button class="round-button" onclick="setRound('Finale')">Finale</button>
            <button class="round-button" onclick="setRound('Spiel um Platz 3')">Platz 3</button>
        </div>
        
        <div class="quick-add">
            <input type="text" id="customRoundInput" placeholder="Eigene Runde eingeben">
            <button onclick="setCustomRound()">Setzen</button>
        </div>
    </div>

    <!-- Tournament Bracket -->
    <div class="control-panel">
        <h2>🏆 Tournament Bracket</h2>
        
        <!-- Bracket Status -->
        <div class="bracket-status not-setup" id="bracketStatus">
            ⚠️ Tournament bracket not set up
        </div>
        
        <!-- Bracket Setup -->
        <div id="bracketSetupSection">
            <h3 style="margin-bottom: 15px;">Bracket Setup (16 Robots)</h3>
            <div class="bracket-setup" id="bracketSetup">
                <!-- Bracket positions will be populated here -->
            </div>
            <div style="margin: 15px 0;">
                <button class="action-button" onclick="setupBracket()">🎯 Create Bracket</button>
                <button class="action-button" onclick="randomAssignRobots()">🎲 Random Assignment</button>
                <button class="action-button" onclick="finishBracketSetup()" id="finishBracketBtn" style="display: none;">✅ Start Tournament</button>
                <button class="action-button danger" onclick="resetBracket()">🔄 Reset Bracket</button>
            </div>
        </div>
        
        <!-- Bracket Display -->
        <div id="bracketDisplaySection" style="display: none;">
            <div class="bracket-container" id="bracketContainer">
                <!-- Tournament bracket will be displayed here -->
            </div>
            
            <div style="margin: 15px 0;">
                <button class="action-button" onclick="getNextMatch()">▶️ Next Match</button>
                <button class="action-button" onclick="editBracketSetup()">⚙️ Edit Setup</button>
            </div>
        </div>
    </div>

    <!-- Overlay Control -->
    <div class="control-panel">
        <h2>📺 OBS Overlay Control</h2>
        <div class="current-match" style="background: linear-gradient(135deg, #17a2b8 0%, #138496 100%);">
            <h3 id="overlayModeDisplay">Current Mode: Match Display</h3>
            <p style="margin: 10px 0 0 0; font-size: 0.9em; opacity: 0.9;">Control what viewers see in OBS</p>
        </div>
        <div class="actions">
            <button class="action-button" onclick="setOverlayMode('match')" id="showMatchBtn">🥊 Show Match</button>
            <button class="action-button" onclick="setOverlayMode('bracket')" id="showBracketBtn">🏆 Show Bracket</button>
            <button class="action-button" onclick="openOverlay()">🖥️ Open Overlay</button>
        </div>
    </div>

    <!-- Timer Control -->
    <div class="control-panel">
        <h2>⏱️ Kampf Timer</h2>
        <div class="current-match" style="background: linear-gradient(135deg, #6f42c1 0%, #5a2d8c 100%);">
            <div id="timerDisplayPanel" class="timer-display">03:00</div>
            <p style="margin: 10px 0 0 0; font-size: 0.9em; opacity: 0.9;">Zeit für den aktuellen Kampf</p>
        </div>
        <div class="timer-controls">
            <div>
                <label for="timerMinutes" style="font-size: 14px; font-weight: bold;">Minuten:</label>
                <input type="number" id="timerMinutes" class="timer-input" value="3" min="0" max="59">
            </div>
            <div>
                <label for="timerSeconds" style="font-size: 14px; font-weight: bold;">Sekunden:</label>
                <input type="number" id="timerSeconds" class="timer-input" value="0" min="0" max="59">
            </div>
            <button class="timer-button" onclick="setTimerDuration()">⚙️ Zeit setzen</button>
        </div>
        <div class="actions">
            <button class="timer-button start" onclick="startTimer()" id="startTimerBtn">▶️ Start</button>
            <button class="timer-button" onclick="pauseTimer()" id="pauseTimerBtn">⏸️ Pause</button>
            <button class="timer-button stop" onclick="stopTimer()" id="stopTimerBtn">⏹️ Stop</button>
            <button class="timer-button" onclick="resetTimer()" id="resetTimerBtn">🔄 Reset</button>
        </div>
    </div>

    <!-- Aktionen -->
    <div class="control-panel">
        <h2>⚙️ Aktionen</h2>
        <div class="actions">
            <button class="action-button" onclick="refreshData()">🔄 Daten neu laden</button>
            <button class="action-button danger" onclick="resetAll()">💥 Alles zurücksetzen</button>
        </div>
    </div>

    <script>
        let selectedSlot = null;
        let currentData = {};
        let currentBracket = {};
        let selectedBracketPosition = null;
        let currentTimer = {};
        let timerUpdateInterval = null;

        // API Aufrufe
        async function apiCall(endpoint, method = 'GET', data = null) {
            try {
                const options = {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                    }
                };
                
                if (data) {
                    options.body = JSON.stringify(data);
                }
                
                const response = await fetch(endpoint, options);
                return await response.json();
            } catch (error) {
                console.error('API Error:', error);
                updateStatus('❌ Verbindungsfehler', 'error');
                return null;
            }
        }

        // Daten laden
        async function loadData() {
            const [data, timer] = await Promise.all([
                apiCall('/api/data'),
                apiCall('/api/timer')
            ]);
            if (data) {
                currentData = data;
                updateDisplay();
                renderRobots();
                await loadBracket();
                await loadOverlayMode();
                updateStatus('✅ Daten geladen', 'success');
            }
            if (timer) {
                currentTimer = timer;
                updateTimerUI();
            }
        }

        // Overlay control functions
        async function loadOverlayMode() {
            const result = await apiCall('/api/overlay/mode');
            if (result) {
                updateOverlayModeDisplay(result.mode);
            }
        }

        async function setOverlayMode(mode) {
            const result = await apiCall('/api/overlay/mode', 'POST', { mode: mode });
            if (result && result.success) {
                updateOverlayModeDisplay(mode);
                const modeText = mode === 'match' ? 'Match Display' : 'Bracket Display';
                updateStatus(`📺 OBS Overlay switched to: ${modeText}`, 'success');
            } else {
                updateStatus('❌ Failed to change overlay mode', 'error');
            }
        }

        function updateOverlayModeDisplay(mode) {
            const display = document.getElementById('overlayModeDisplay');
            const matchBtn = document.getElementById('showMatchBtn');
            const bracketBtn = document.getElementById('showBracketBtn');
            
            if (mode === 'match') {
                display.textContent = 'Current Mode: Match Display';
                matchBtn.style.background = '#28a745';
                bracketBtn.style.background = '#6c757d';
            } else {
                display.textContent = 'Current Mode: Bracket Display';
                matchBtn.style.background = '#6c757d';
                bracketBtn.style.background = '#28a745';
            }
        }

        // Bracket Functions
        async function loadBracket() {
            const bracket = await apiCall('/api/bracket');
            if (bracket) {
                currentBracket = bracket;
                updateBracketDisplay();
            }
        }

        function updateBracketDisplay() {
            updateBracketStatus();
            
            // Don't automatically change display if user is explicitly managing it
            // Only auto-switch for 'not_setup' status
            if (currentBracket.status === 'not_setup') {
                showBracketSetup();
            }
            // For 'setup' and 'running' status, let user control the display
            // unless no display is currently shown
            else {
                const setupVisible = document.getElementById('bracketSetupSection').style.display !== 'none';
                const displayVisible = document.getElementById('bracketDisplaySection').style.display !== 'none';
                
                // If neither is visible, default based on status
                if (!setupVisible && !displayVisible) {
                    if (currentBracket.status === 'setup') {
                        showBracketSetup();
                    } else {
                        document.getElementById('bracketSetupSection').style.display = 'none';
                        document.getElementById('bracketDisplaySection').style.display = 'block';
                        renderBracket();
                    }
                }
                // Otherwise, maintain current display and just update content
                else if (setupVisible) {
                    renderBracketSetup();
                } else if (displayVisible) {
                    renderBracket();
                }
            }
        }

        function updateBracketStatus() {
            const statusEl = document.getElementById('bracketStatus');
            const status = currentBracket.status || 'not_setup';
            
            statusEl.className = `bracket-status ${status}`;
            
            const statusMessages = {
                'not_setup': '⚠️ Tournament bracket not set up',
                'setup': '🔧 Bracket created - Ready to assign robots',
                'running': '🏃 Tournament in progress',
                'completed': '🏆 Tournament completed!'
            };
            
            statusEl.textContent = statusMessages[status] || statusMessages['not_setup'];
        }

        function showBracketSetup() {
            document.getElementById('bracketSetupSection').style.display = 'block';
            document.getElementById('bracketDisplaySection').style.display = 'none';
            renderBracketSetup();
        }

        function renderBracketSetup() {
            const setupContainer = document.getElementById('bracketSetup');
            setupContainer.innerHTML = '';
            
            let filledCount = 0;
            
            for (let i = 1; i <= 16; i++) {
                const positionDiv = document.createElement('div');
                positionDiv.className = 'bracket-position';
                positionDiv.id = `pos_${i}`;
                positionDiv.onclick = () => selectBracketPosition(i);
                
                const robot = currentBracket.bracket_positions?.[`pos_${i}`] || 'TBD';
                positionDiv.textContent = robot === 'TBD' ? `Position ${i}` : robot;
                
                if (robot !== 'TBD') {
                    positionDiv.classList.add('filled');
                    filledCount++;
                }
                
                setupContainer.appendChild(positionDiv);
            }
            
            // Show finish button if all positions are filled and not yet running
            const finishBtn = document.getElementById('finishBracketBtn');
            if (filledCount === 16 && currentBracket.status === 'setup') {
                finishBtn.style.display = 'inline-block';
                finishBtn.textContent = '✅ Start Tournament';
                updateStatus(`📋 All 16 positions filled! Ready to start tournament.`, 'success');
            } else if (currentBracket.status === 'running') {
                finishBtn.style.display = 'inline-block';
                finishBtn.textContent = '👁️ View Bracket';
                finishBtn.onclick = () => {
                    document.getElementById('bracketSetupSection').style.display = 'none';
                    document.getElementById('bracketDisplaySection').style.display = 'block';
                    renderBracket();
                    updateStatus('📊 Viewing tournament bracket', 'success');
                };
                if (filledCount === 16) {
                    updateStatus(`⚙️ Tournament running - ${filledCount}/16 positions filled`, 'success');
                } else {
                    updateStatus(`⚙️ Tournament running - ${filledCount}/16 positions filled. Edit carefully!`, 'warning');
                }
            } else {
                finishBtn.style.display = 'none';
                if (currentBracket.status === 'setup') {
                    updateStatus(`📋 ${filledCount}/16 positions filled. Select position then click robot.`, 'warning');
                }
            }
        }

        async function finishBracketSetup() {
            // Check if all positions are filled
            const filledCount = Object.values(currentBracket.bracket_positions || {}).filter(r => r !== 'TBD').length;
            if (filledCount < 16) {
                updateStatus('❌ All 16 positions must be filled before starting tournament', 'error');
                return;
            }
            
            // Call API to start tournament
            const result = await apiCall('/api/bracket/start', 'POST');
            if (result && result.success) {
                // Update bracket data
                currentBracket = result.bracket;
                
                // Force display to bracket view
                document.getElementById('bracketSetupSection').style.display = 'none';
                document.getElementById('bracketDisplaySection').style.display = 'block';
                
                // Render the bracket
                renderBracket();
                updateBracketStatus();
                
                updateStatus('🏁 Tournament started! Bracket is now active.', 'success');
            } else {
                updateStatus(`❌ ${result?.message || 'Failed to start tournament'}`, 'error');
            }
        }

        function selectBracketPosition(position) {
            if (selectedBracketPosition) {
                document.getElementById(`pos_${selectedBracketPosition}`).style.background = '';
            }
            
            selectedBracketPosition = position;
            document.getElementById(`pos_${position}`).style.background = '#fff5f2';
            updateStatus(`Position ${position} selected - Click a robot to assign`, 'warning');
        }

        async function setupBracket() {
            const result = await apiCall('/api/bracket/setup', 'POST');
            if (result && result.success) {
                await loadBracket();
                updateStatus('✅ Tournament bracket created - Assign robots manually', 'success');
                document.getElementById('bracketSetupSection').style.display = 'block';
                document.getElementById('bracketDisplaySection').style.display = 'none';
            } else {
                updateStatus('❌ Failed to create bracket', 'error');
            }
        }

        async function randomAssignRobots() {
            if (currentData.robots.length < 16) {
                updateStatus(`❌ Need 16 robots for bracket, only ${currentData.robots.length} available`, 'error');
                return;
            }
            
            const result = await apiCall('/api/bracket/setup', 'POST', {
                robots: currentData.robots,
                random: true
            });
            
            if (result && result.success) {
                await loadBracket();
                updateStatus('✅ Robots randomly assigned to bracket - Ready to start tournament!', 'success');
                // Stay in setup mode so user can review assignments and manually start
                renderBracketSetup();
            } else {
                updateStatus('❌ Failed to assign robots', 'error');
            }
        }

        async function resetBracket() {
            if (confirm('🚨 Reset tournament bracket? This will clear all matches and assignments.')) {
                const result = await apiCall('/api/bracket/reset', 'POST');
                if (result && result.success) {
                    await loadBracket();
                    updateStatus('🔄 Tournament bracket reset', 'success');
                }
            }
        }

        function renderBracket() {
            const container = document.getElementById('bracketContainer');
            container.innerHTML = '';
            
            if (!currentBracket.matches || Object.keys(currentBracket.matches).length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #6c757d;">No bracket data available</p>';
                return;
            }
            
            // Round 1
            const round1 = createRoundDiv('Round 1', ['r1_m1', 'r1_m2', 'r1_m3', 'r1_m4', 'r1_m5', 'r1_m6', 'r1_m7', 'r1_m8']);
            container.appendChild(round1);
            
            // Quarterfinals
            const qf = createRoundDiv('Quarterfinals', ['qf_m1', 'qf_m2', 'qf_m3', 'qf_m4']);
            container.appendChild(qf);
            
            // Semifinals
            const sf = createRoundDiv('Semifinals', ['sf_m1', 'sf_m2']);
            container.appendChild(sf);
            
            // Finals
            const finals = createRoundDiv('Finals', ['final']);
            container.appendChild(finals);
        }

        function createRoundDiv(roundName, matchIds) {
            const roundDiv = document.createElement('div');
            roundDiv.className = 'bracket-round';
            
            const header = document.createElement('h4');
            header.textContent = roundName;
            roundDiv.appendChild(header);
            
            matchIds.forEach(matchId => {
                if (currentBracket.matches[matchId]) {
                    const matchDiv = createMatchDiv(matchId, currentBracket.matches[matchId]);
                    roundDiv.appendChild(matchDiv);
                }
            });
            
            return roundDiv;
        }

        function createMatchDiv(matchId, match) {
            const matchDiv = document.createElement('div');
            matchDiv.className = 'bracket-match';
            matchDiv.id = `match_${matchId}`;
            
            if (match.completed) {
                matchDiv.classList.add('completed');
            }
            
            if (currentBracket.current_match_id === matchId) {
                matchDiv.classList.add('current');
            }
            
            matchDiv.onclick = () => selectBracketMatch(matchId);
            
            const header = document.createElement('div');
            header.className = 'bracket-match-header';
            header.textContent = matchId.toUpperCase().replace('_', ' ');
            matchDiv.appendChild(header);
            
            const robotsDiv = document.createElement('div');
            robotsDiv.className = 'bracket-robots';
            
            // Robot 1
            const robot1Div = document.createElement('div');
            robot1Div.className = 'bracket-robot';
            robot1Div.textContent = match.robot1;
            if (match.winner === match.robot1) {
                robot1Div.classList.add('winner');
            }
            // Add click handler for direct winner selection
            if (!match.completed && match.robot1 !== 'TBD' && !match.robot1.includes('winner_')) {
                robot1Div.classList.add('clickable');
                robot1Div.addEventListener('click', (e) => {
                    e.stopPropagation();
                    setMatchWinner(matchId, match.robot1);
                });
                robot1Div.title = 'Click to set as winner';
            }
            
            // Robot 2
            const robot2Div = document.createElement('div');
            robot2Div.className = 'bracket-robot';
            robot2Div.textContent = match.robot2;
            if (match.winner === match.robot2) {
                robot2Div.classList.add('winner');
            }
            // Add click handler for direct winner selection
            if (!match.completed && match.robot2 !== 'TBD' && !match.robot2.includes('winner_')) {
                robot2Div.classList.add('clickable');
                robot2Div.addEventListener('click', (e) => {
                    e.stopPropagation();
                    setMatchWinner(matchId, match.robot2);
                });
                robot2Div.title = 'Click to set as winner';
            }
            
            robotsDiv.appendChild(robot1Div);
            robotsDiv.appendChild(robot2Div);
            matchDiv.appendChild(robotsDiv);
            
            // Add undo button for completed matches
            if (match.completed && match.winner) {
                const undoDiv = document.createElement('div');
                undoDiv.style.marginTop = '8px';
                undoDiv.style.textAlign = 'center';
                
                const undoButton = document.createElement('button');
                undoButton.textContent = '↶ Undo';
                undoButton.style.background = '#dc3545';
                undoButton.style.color = 'white';
                undoButton.style.border = 'none';
                undoButton.style.padding = '4px 12px';
                undoButton.style.borderRadius = '4px';
                undoButton.style.fontSize = '11px';
                undoButton.style.cursor = 'pointer';
                undoButton.title = `Undo result: ${match.winner} wins`;
                
                undoButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    undoMatchResult(matchId);
                });
                
                undoDiv.appendChild(undoButton);
                matchDiv.appendChild(undoDiv);
            }
            
            return matchDiv;
        }

        async function setMatchWinner(matchId, winner) {
            console.log('setMatchWinner called:', matchId, winner);
            updateStatus(`Setting winner: ${winner} for ${matchId}`, 'warning');
            
            if (confirm(`Set ${winner} as winner of ${matchId.toUpperCase().replace('_', ' ')}?`)) {
                const result = await apiCall(`/api/bracket/match/${matchId}`, 'POST', {
                    winner: winner
                });
                if (result && result.success) {
                    await loadBracket();
                    updateStatus(`🏆 ${winner} wins ${matchId.toUpperCase().replace('_', ' ')}! Advanced to next round.`, 'success');
                } else {
                    updateStatus(`❌ ${result?.message || 'Failed to set winner'}`, 'error');
                }
            } else {
                updateStatus('Winner selection cancelled', 'warning');
            }
        }

        async function undoMatchResult(matchId) {
            const match = currentBracket.matches[matchId];
            if (!match || !match.completed) {
                updateStatus('❌ Match is not completed', 'error');
                return;
            }

            const matchName = matchId.toUpperCase().replace('_', ' ');
            if (confirm(`🚨 Undo result for ${matchName}?\n\nThis will:\n- Remove ${match.winner} as winner\n- Reset the match to not completed\n- Clear winner from next round matches\n\nNote: If dependent matches are completed, they must be undone first.`)) {
                updateStatus(`Undoing result for ${matchName}...`, 'warning');
                
                const result = await apiCall(`/api/bracket/match/${matchId}/undo`, 'POST');
                if (result && result.success) {
                    await loadBracket();
                    await loadData(); // Refresh current match data too
                    updateStatus(`↶ ${matchName} result undone successfully`, 'success');
                } else {
                    updateStatus(`❌ ${result?.message || 'Failed to undo match result'}`, 'error');
                }
            }
        }

        async function selectBracketMatch(matchId) {
            const match = currentBracket.matches[matchId];
            if (!match) return;
            
            if (match.completed) {
                updateStatus(`Match ${matchId} already completed. Winner: ${match.winner}`, 'warning');
                return;
            }
            
            if (match.robot1.includes('winner_') || match.robot2.includes('winner_')) {
                updateStatus(`Match ${matchId} waiting for previous matches to complete`, 'warning');
                return;
            }
            
            // Set as current match
            const result = await apiCall('/api/bracket/current', 'POST', { match_id: matchId });
            if (result && result.success) {
                await loadData();
                updateStatus(`✅ Current match set: ${match.robot1} vs ${match.robot2}`, 'success');
            }
        }

        async function getNextMatch() {
            const result = await apiCall('/api/bracket/current');
            if (result) {
                if (result.suggested_match_id) {
                    await selectBracketMatch(result.suggested_match_id);
                } else if (result.current_match_id) {
                    updateStatus(`Current match: ${result.match.robot1} vs ${result.match.robot2}`, 'success');
                } else {
                    updateStatus('No available matches', 'warning');
                }
            }
        }

        function editBracketSetup() {
            document.getElementById('bracketSetupSection').style.display = 'block';
            document.getElementById('bracketDisplaySection').style.display = 'none';
            renderBracketSetup();
            
            if (currentBracket.status === 'running') {
                updateStatus('⚙️ Editing active tournament - Changes will update matches immediately', 'warning');
            } else {
                updateStatus('⚙️ Bracket setup mode - Click positions to reassign robots', 'warning');
            }
        }

        // Display aktualisieren
        function updateDisplay() {
            const robot1Name = currentData.current_match?.robot1 || 'Roboter 1';
            const robot2Name = currentData.current_match?.robot2 || 'Roboter 2';
            
            document.getElementById('currentRobot1').textContent = robot1Name;
            document.getElementById('currentRobot2').textContent = robot2Name;
            document.getElementById('currentRound').textContent = currentData.current_match?.round || 'Runde';
            
            // Update winner button texts
            document.getElementById('robot1Name').textContent = robot1Name;
            document.getElementById('robot2Name').textContent = robot2Name;
            
            // Update tournament title input only if not currently focused (being edited)
            const titleInput = document.getElementById('tournamentTitleInput');
            if (currentData.tournament_settings?.title && titleInput && document.activeElement !== titleInput) {
                titleInput.value = currentData.tournament_settings.title;
            }
        }

        // Roboter Grid rendern
        function renderRobots() {
            const grid = document.getElementById('robotGrid');
            grid.innerHTML = '';
            
            if (currentData.robots) {
                currentData.robots.forEach(robot => {
                    const button = document.createElement('button');
                    button.className = 'robot-button';
                    button.textContent = robot;
                    button.onclick = () => selectRobot(robot);
                    
                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-btn';
                    deleteBtn.textContent = '×';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteRobot(robot);
                    };
                    
                    button.appendChild(deleteBtn);
                    grid.appendChild(button);
                });
            }
            
            updateStatus(`📚 ${currentData.robots?.length || 0} Roboter verfügbar`, 'success');
        }

        // Slot auswählen
        function selectSlot(slotNumber) {
            selectedSlot = slotNumber;
            
            document.querySelectorAll('.slot-button').forEach(btn => btn.classList.remove('selected'));
            document.getElementById(`slot${slotNumber}Button`).classList.add('selected');
            
            updateStatus(`🎯 Slot ${slotNumber} ausgewählt - Roboter anklicken!`, 'warning');
        }

        // Roboter auswählen
        async function selectRobot(robotName) {
            // Handle bracket position assignment
            if (selectedBracketPosition) {
                const result = await apiCall('/api/bracket/assign', 'POST', {
                    position: `pos_${selectedBracketPosition}`,
                    robot: robotName
                });
                
                if (result && result.success) {
                    await loadBracket();
                    updateStatus(`✅ ${robotName} assigned to position ${selectedBracketPosition}`, 'success');
                    
                    // Clear selection
                    document.getElementById(`pos_${selectedBracketPosition}`).style.background = '';
                    selectedBracketPosition = null;
                    return;
                } else {
                    updateStatus(`❌ ${result?.message || 'Failed to assign robot'}`, 'error');
                    return;
                }
            }
            
            // Handle current match winner selection
            if (currentBracket.current_match_id) {
                const match = currentBracket.matches[currentBracket.current_match_id];
                if (match && !match.completed && (robotName === match.robot1 || robotName === match.robot2)) {
                    if (confirm(`Set ${robotName} as winner of current match?`)) {
                        const result = await apiCall(`/api/bracket/match/${currentBracket.current_match_id}`, 'POST', {
                            winner: robotName
                        });
                        if (result && result.success) {
                            await loadData();
                            updateStatus(`✅ ${robotName} wins! Advancing to next round.`, 'success');
                            return;
                        }
                    }
                }
            }
            
            // Handle regular slot selection
            if (!selectedSlot) {
                updateStatus('⚠️ Bitte erst einen Slot auswählen!', 'error');
                return;
            }

            const matchData = {};
            matchData[`robot${selectedSlot}`] = robotName;
            
            const result = await apiCall('/api/match', 'POST', matchData);
            if (result && result.success) {
                await loadData();
                updateStatus(`✅ ${robotName} → Slot ${selectedSlot}`, 'success');
                
                // Slot deselektieren
                selectedSlot = null;
                document.querySelectorAll('.slot-button').forEach(btn => btn.classList.remove('selected'));
            }
        }

        // Roboter hinzufügen
        async function addRobot() {
            const name = document.getElementById('newRobotInput').value.trim();
            if (!name) {
                updateStatus('⚠️ Bitte einen Namen eingeben!', 'error');
                return;
            }

            const result = await apiCall('/api/robots', 'POST', { name: name });
            if (result && result.success) {
                document.getElementById('newRobotInput').value = '';
                await loadData();
                updateStatus(`✅ ${name} hinzugefügt`, 'success');
            } else {
                updateStatus(`❌ ${result?.message || 'Fehler beim Hinzufügen'}`, 'error');
            }
        }

        // Test-Roboter generieren
        async function generateTestRobots() {
            if (confirm('Alle vorhandenen Roboter werden gelöscht und 16 Test-Roboter generiert. Fortfahren?')) {
                const result = await apiCall('/api/robots/generate-test-data', 'POST');
                if (result && result.success) {
                    await loadData();
                    updateStatus(`✅ ${result.message}`, 'success');
                } else {
                    updateStatus(`❌ ${result?.message || 'Fehler beim Generieren der Test-Daten'}`, 'error');
                }
            }
        }

        // Roboter löschen
        async function deleteRobot(robotName) {
            if (confirm(`Roboter "${robotName}" wirklich löschen?`)) {
                const result = await apiCall(`/api/robots/${encodeURIComponent(robotName)}`, 'DELETE');
                if (result && result.success) {
                    await loadData();
                    updateStatus(`🗑️ ${robotName} gelöscht`, 'success');
                }
            }
        }

        // Runde setzen
        async function setRound(roundName) {
            const result = await apiCall('/api/match', 'POST', { round: roundName });
            if (result && result.success) {
                await loadData();
                
                // UI Update
                document.querySelectorAll('.round-button').forEach(btn => btn.classList.remove('active'));
                event.target.classList.add('active');
                
                updateStatus(`🏆 Runde: ${roundName}`, 'success');
            }
        }

        // Eigene Runde
        async function setCustomRound() {
            const roundName = document.getElementById('customRoundInput').value.trim();
            if (roundName) {
                await setRound(roundName);
                document.getElementById('customRoundInput').value = '';
            }
        }

        // Status aktualisieren
        function updateStatus(message, type = 'success') {
            const statusEl = document.getElementById('statusDisplay');
            statusEl.textContent = message;
            statusEl.className = `status-bar ${type}`;
        }

        // Daten neu laden
        async function refreshData() {
            await loadData();
        }

        // Alles zurücksetzen
        async function resetAll() {
            if (confirm('🚨 ALLE Daten zurücksetzen?')) {
                const result = await apiCall('/api/reset', 'POST');
                if (result && result.success) {
                    await loadData();
                    updateStatus('🔄 Daten zurückgesetzt', 'success');
                }
            }
        }

        // Overlay öffnen
        function openOverlay() {
            window.open('/overlay', '_blank');
        }

        // Tastatur Shortcuts
        document.addEventListener('keydown', function(event) {
            if (event.key === '1') selectSlot(1);
            if (event.key === '2') selectSlot(2);
            if (event.key === 'F5') {
                event.preventDefault();
                refreshData();
            }
        });

        // Enter in Input Feldern
        document.getElementById('newRobotInput').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') addRobot();
        });

        document.getElementById('customRoundInput').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') setCustomRound();
        });

        document.getElementById('tournamentTitleInput').addEventListener('keypress', function(event) {
            if (event.key === 'Enter') updateTournamentTitle();
        });

        // Timer functions
        function updateTimerUI() {
            const display = document.getElementById('timerDisplayPanel');
            if (!display) return;
            
            display.textContent = currentTimer.remaining_formatted || '00:00';
            
            // Remove all status classes
            display.classList.remove('running', 'warning', 'critical', 'paused');
            
            // Add appropriate status class
            if (currentTimer.is_paused) {
                display.classList.add('paused');
            } else if (currentTimer.is_running) {
                display.classList.add('running');
                
                if (currentTimer.remaining <= 30) {
                    display.classList.add('critical');
                } else if (currentTimer.remaining <= 60) {
                    display.classList.add('warning');
                }
            }
        }

        async function setTimerDuration() {
            const minutes = parseInt(document.getElementById('timerMinutes').value) || 0;
            const seconds = parseInt(document.getElementById('timerSeconds').value) || 0;
            const totalSeconds = minutes * 60 + seconds;
            
            if (totalSeconds <= 0) {
                updateStatus('❌ Timer duration must be greater than 0', 'error');
                return;
            }
            
            const result = await apiCall('/api/timer', 'POST', {
                duration: totalSeconds
            });
            
            if (result && result.success) {
                currentTimer = result.timer;
                updateTimerUI();
                updateStatus(`⏱️ Timer set to ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`, 'success');
            }
        }

        async function startTimer() {
            const result = await apiCall('/api/timer', 'POST', {
                action: 'start'
            });
            
            if (result && result.success) {
                currentTimer = result.timer;
                updateTimerUI();
                updateStatus('▶️ Timer started', 'success');
                startTimerUpdates();
            }
        }

        async function pauseTimer() {
            const result = await apiCall('/api/timer', 'POST', {
                action: 'pause'
            });
            
            if (result && result.success) {
                currentTimer = result.timer;
                updateTimerUI();
                updateStatus('⏸️ Timer paused', 'info');
                stopTimerUpdates();
            }
        }

        async function stopTimer() {
            const result = await apiCall('/api/timer', 'POST', {
                action: 'stop'
            });
            
            if (result && result.success) {
                currentTimer = result.timer;
                updateTimerUI();
                updateStatus('⏹️ Timer stopped', 'info');
                stopTimerUpdates();
            }
        }

        async function resetTimer() {
            const result = await apiCall('/api/timer', 'POST', {
                action: 'reset'
            });
            
            if (result && result.success) {
                currentTimer = result.timer;
                updateTimerUI();
                updateStatus('🔄 Timer reset', 'info');
                stopTimerUpdates();
            }
        }

        function startTimerUpdates() {
            stopTimerUpdates(); // Clear any existing interval
            timerUpdateInterval = setInterval(async () => {
                const timer = await apiCall('/api/timer');
                if (timer) {
                    currentTimer = timer;
                    updateTimerUI();
                    
                    if (!timer.is_running && !timer.is_paused) {
                        stopTimerUpdates();
                    }
                }
            }, 1000);
        }

        function stopTimerUpdates() {
            if (timerUpdateInterval) {
                clearInterval(timerUpdateInterval);
                timerUpdateInterval = null;
            }
        }

        // Winner Animation Functions
        async function announceWinner(winnerRobot) {
            const result = await apiCall('/api/winner', 'POST', {
                winner: winnerRobot
            });
            
            if (result && result.success) {
                const robotName = winnerRobot === 'robot1' 
                    ? (currentData.current_match?.robot1 || 'Robot 1') 
                    : (currentData.current_match?.robot2 || 'Robot 2');
                updateStatus(`🎉 ${robotName} is the winner! Animation started.`, 'success');
            } else {
                updateStatus(`❌ Failed to announce winner: ${result?.message || 'Unknown error'}`, 'error');
            }
        }

        async function resetWinnerAnimation() {
            const result = await apiCall('/api/winner/reset', 'POST');
            
            if (result && result.success) {
                updateStatus('🔄 Winner animation reset', 'success');
            } else {
                updateStatus('❌ Failed to reset winner animation', 'error');
            }
        }

        // Tournament Title Functions
        async function updateTournamentTitle() {
            const title = document.getElementById('tournamentTitleInput').value.trim();
            if (!title) {
                updateStatus('⚠️ Bitte einen Titel eingeben!', 'error');
                return;
            }

            const result = await apiCall('/api/tournament/title', 'POST', { title: title });
            if (result && result.success) {
                await loadData();
                updateStatus(`🏆 Tournament Titel gesetzt: "${title}"`, 'success');
            } else {
                updateStatus(`❌ ${result?.message || 'Fehler beim Setzen des Titels'}`, 'error');
            }
        }

        // Auto-refresh alle 5 Sekunden
        setInterval(loadData, 5000);

        // Initial laden
        loadData();
    </script>
</body>
</html>